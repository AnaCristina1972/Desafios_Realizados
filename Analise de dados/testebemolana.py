# -*- coding: utf-8 -*-
"""TesteBemolAna.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1958ciLQMgBqywBIx8solT2WwOg6Eq7Se

###Candidata:Ana Cristina da Silva Vieira

#Lógica de programação
"""

from numpy import *

""" 1. Crie um programa que receba duas idades inteiras e imprima na tela a maior idade."""

idade=input("Digite uma idades, por favor.")
idade2=input("Digite outra idades, por favor.")
maior=max(idade, idade2)
print("A maior idade é: ", maior)

"""2.  Dado uma lista de números inteiros, escreva um programa para calcular a soma de todos os elementos da
lista.
"""

lista=[2,3,4,5,6,7,8,9,12]
soma=sum(lista)
print("O total acumulado da lista é: ",soma)

"""3. Escreva um programa que receba uma string e retorne a mesma string, mas com as vogais removidas.

"""

texto=input("Digite um texto")
Vogais="AEIOUaeiou"
texto_filotrado=str.maketrans("","",Vogais)
text=texto.translate(texto_filotrado)
print(text)

"""4. Escreva um programa que imprima na tela os primeiros 10 números da sequência de Fibonacci.

"""

a,b,aux,i=0,1,0,0
for i in range(0,10):
  aux=a
  a=b
  b=a+aux
  print(f"O {i+1}º da serie",  aux)

"""5. Dado um número inteiro, escreva um programa para verificar se ele é um número primo.

"""

primo=int(input("digite um valor: "))
#primo+=1
primo1=False
if primo>1 :
    primo1=True

    for i in range(2,int(primo**0.5)+1):

        if(primo%i==0):
           primo1=False
           print(f"O numero {primo} não é primo...  ")
if primo1:
    print(f"O numero {primo} é primo ")

"""6. Dado uma lista de strings, escreva um programa que retorne uma lista com as strings ordenadas pelo seu
tamanho.

"""

lista_strings = []
qtd=int(input("Quantas palavras você deseja? "))
for i in range(0,qtd):
  palavras=input(f"\nDigite a {i+1}ª palavra desejada: ")
  lista_strings.append(palavras)
strings_ordenadas = sorted(lista_strings,key=len)
print("\nLista inicial: ", lista_strings)
print("\nLista ordenada: ", strings_ordenadas)

"""
7. Dada uma string, escreva um programa que retorne à primeira letra que não se repete.
"""

from collections import Counter

def colecao_Unica(string):
    contagem = Counter(string)
    for char in string:
        if contagem[char] == 1:
            return char

    return None
entrada = input("Digite uma string: ")
letras = colecao_Unica(entrada)
if letras:
    print(f"A primeira letra não repetida é: {letras}")
else:
    print("Não há letras não repetidas na string.")

"""8. Dado um número inteiro positivo, escreva um programa que encontre o fatorial deste número.

"""

import math
numero = int(input("Digite um número inteiro positivo: "))
if numero < 0:
    print("O fatorial não está definido para números negativos.")
else:
    fatorial = math.factorial(numero)
    print(f"O fatorial de {numero} é {fatorial}")

"""9. Crie um minijogo “adivinhe o número”, o jogador terá que adivinhar qual é o número coringa (37), ele pode
ter 5 tentativas, se acertar (aqui entende-se acertar se o jogador inserir o número 37), revele o número,
caso exceda, imprima na tela “Game Over”. Informar na tela que o número oculto é entre 0 e 100.

"""

import random
import os
numero = random.randint(0, 9)

chances=0
print("Olá, vamos jogar??? Você 3 chances para adivinhar o numero que vai sair... \n Vamos começar???\nObs: (Siga dando enter)")
input()
os.system('cls')



print("gerando numero...")
input()
os.system('cls')
print("Numero gerado, agora adivinhe qual numero saiu.\n Não esqueça, você tem 3 chaces...")
while chances<3:
        chutes = int(input("Adivinhe o número (entre 0 e 9): "))
        chances+= 1
        if chutes == numero:
            print("Parabéns! Você acertou o número.")
            break
        else:
            print(f"Não, você errou. Você só ja tem mais ",3-chances)
            input()
            os.system('cls')
        if chances == 3:
            print(f"Game Over. O número era {numero}.")

"""10. Crie um programa que receba 10 números e ordene em ordem crescente.

"""

entrada = input("Digite os elementos do vetor separados por espaço: ")

vetor = [int(x) for x in entrada.split()]

# Ordene o vetor em ordem crescente
vetor_ordenado = sorted(vetor)

# Imprima o vetor ordenado
print("Vetor em ordem crescente:", vetor_ordenado)

vetor = []
vetor_ordenado=[]
qtd=int(input("Qual o tamanho do vetor? "))
for i in range(0,qtd):
  numero=input(f"\nDigite o {i+1}º valor: ")
  vetor.append(int(numero))
print("\nVetor inicial: ", vetor)
vetor_ordenado=sorted(vetor)
print("\nVetor ordenado: ", vetor_ordenado)

"""11. Crie um programa que receba a string “Inteligência de Negócio” e imprima “oicógeN ed aicnêgiletnI”

"""

entrada = "Inteligência de Negócio"
saida = entrada[::-1]
print(saida)

"""12. Crie um programa que calcule o delta de uma equação do segundo grau (ax² + bx + c = 0)

"""

a,b,c,delta=0,0,0,0
a=int(input("Digite o valor de A." ))
if a==0:
  print("O A não pode ser zero, assim se tornara uma equação linear")
else:
  delta=b**2-4**c
  print(f"O valor do delta: {delta}")

"""13. Dado um conjunto de números inteiros não-negativos e um valor alvo, determine se existe um subconjunto
do conjunto original cuja soma é igual ao valor alvo6. Dado uma lista de strings, escreva um programa que retorne uma lista com as strings ordenadas pelo seu
tamanho.

#Questões de dados
"""

import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import plotly.express as px
import pandas as pd

clientes=pd.read_csv("/content/olist_customers_dataset.csv")
geolocation=pd.read_csv("/content/olist_geolocation_dataset.csv")
order_items=pd.read_csv("/content/olist_order_items_dataset.csv")
order_pagamento=pd.read_csv("/content/olist_order_payments_dataset.csv")
order_reviews=pd.read_csv("/content/olist_order_reviews_dataset.csv")
_orders=pd.read_csv("/content/olist_orders_dataset.csv")
products=pd.read_csv("/content/olist_products_dataset.csv")
sellers=pd.read_csv("/content/olist_sellers_dataset.csv")
category_name_translation=pd.read_csv("/content/product_category_name_translation.csv")

"""##1. Monte uma tabela geral com as colunas mais importantes (a seu critério). Justifique a escolha dessas



"""

clientes

products

geolocation

sellers

category_name_translation

order_reviews

order_items

order_pagamento

_orders

frame1 = pd.merge(_orders[["order_id","customer_id","order_status","order_purchase_timestamp","order_estimated_delivery_date"]], clientes[["customer_id","customer_city","customer_state"]],  on='customer_id', how='left')
frame1

frameGeral1=pd.merge(frame1, order_items,  on='order_id', how='left')

frameGeral1

frameGeral2=pd.merge(frameGeral1, order_pagamento,  on='order_id', how='left')
frameGeral2
#Ticket Médio = Total recebido / Número de vendas

"""## Justificativa

As junções entre essas tabelas podem ser usadas para responder a perguntas como:

* Quais produtos são mais vendidos por região?
* Quais clientes gastaram mais dinheiro em determinada categoria de produtos?
* Qual é a média de gastos dos clientes por mês?
* Quais produtos têm os maiores lucros?

Ao combinar essas tabelas, é possível obter uma visão mais completa do desempenho da empresa, identificar oportunidades de negócios e tomar decisões estratégicas informadas. Portanto, a junção dessas tabelas é crucial para uma análise eficaz dos dados empresariais.

##2. Faça uma análise do volume de vendas e o ticket médio, quais impressões você tira ao cruzar esses dados com a data de compra. Construa gráficos e tabelas que o ajudem tirar insights e apresentar os dados analisados.
"""

frameGeral=pd.merge(frameGeral2, sellers,  on='seller_id', how='left')
frameGeral

anos=frameGeral['order_purchase_timestamp'].unique()
max(anos)

min(anos)



titulos_colunas = frameGeral.columns
titulos_colunas

import pandas as pd
import matplotlib.pyplot as plt
#Ticket Médio = Total recebido / Número de vendas
# 200 vendas por dia, e determinado mês teve 31 dias, a conta será: 200 x 31 = 6200 vendas naquele mês
#
dados=frameGeral[['seller_id','order_id','order_purchase_timestamp','price']]
# Calculando o volume de vendas total por vendedor
dados

dadosvolume_vendas = dados.groupby('order_id')['order_purchase_timestamp'].sum().reset_index()
ticket_medio_por_vendedor = frameGeral.groupby('seller_id')['price'].mean().reset_index()
ticket_medio_por_vendedor.rename(columns={'price': 'ticket_medio'}, inplace=True)
print(ticket_medio_por_vendedor)
plt.figure(figsize=(10, 5))
plt.bar(ticket_medio_por_vendedor['seller_id'].astype(str), ticket_medio_por_vendedor['ticket_medio'])
plt.xlabel('Vendedor ID')
plt.ylabel('Ticket Médio')
plt.title('Ticket Médio por Vendedor (usando IDs)')
plt.show()

"""#Analise do tickt médio por vendedor

O grafico mostra que o  tickt médio fica em torno de 176.350354 para a maioria dos vendedores.
"""

ticket_medio_por_vendedor.describe()

titulos_colunas = dados.columns
titulos_colunas

# Convertendo a coluna de datas para o tipo de dados datetime
dados['order_purchase_timestamp'] = pd.to_datetime(dados['order_purchase_timestamp'])

# Definindo a coluna de data como o índice
dados.set_index('order_purchase_timestamp', inplace=True)

#Resample das vendas por mês e contar o número de vendas em cada mês
vendas_por_mes = dados.resample('M')['order_id'].count()

#Plotando o volume de vendas ao longo do tempo
plt.figure(figsize=(10, 5))
vendas_por_mes.plot(kind='line', marker='o')
plt.xlabel('Mês')
plt.ylabel('Volume de Vendas')
plt.title('Volume de Vendas ao Longo do Tempo')
plt.grid(True)
plt.show()

"""#Analise dos dados
De acordo com a grafico podemos perceber que as venda crescen no final do ano de 2017 e continua em alta até abril do ano seguite. Porém , a maioria das vezes, o volume de venda ficam entre 3.900 a 5.000 entre os meses de abril a outobro de 2017. Contudo, nas estremidades o volume quase zerou.
"""

totalVenda=frameGeral['order_id'].sum()

totalVenda

tabelaDePagamento=frameGeral['payment_type']
tabelaDePagamento.describe()

"""3. Faça uma análise do valor do frete. Busque entender sua influência (se houver) sobre o volume de vendas e
ticket médio. Traga visões por estado e região. Caso faça sentido, sugira políticas de frete que incentive a
compra nos estados de menor volume de vendas.

4. Elabore um mapa de calor buscando identificar dias e horários de pico.
"""

dados['order_purchase_timestamp'] = pd.to_datetime(dados['order_purchase_timestamp'])

# Extraindo o dia da semana e a hora do dia
dados['dia_da_semana'] = dados['order_purchase_timestamp'].dt.day_name()
dados['hora_do_dia'] = dados['order_purchase_timestamp'].dt.hour

# Criando uma tabela dinâmica (pivot table) com a contagem de pedidos por dia da semana e hora do dia
tabela_pivot = dados.pivot_table(index='dia_da_semana', columns='hora_do_dia', values='order_id', aggfunc='count')

# Plotando o mapa de calor
plt.figure(figsize=(12, 8))
sns.heatmap(tabela_pivot, cmap='YlGnBu', annot=True, fmt='d', cbar=True)
plt.title('Mapa de Calor de Dias e Horas de Pico de Pedidos')
plt.xlabel('Hora do Dia')
plt.ylabel('Dia da Semana')
plt.show()

"""5. Cruze os dados das formas de pagamento e o ticket médio das compras, verifique se existe alguma
correlação.

"""

ticket_medio_por_forma_pagamento = frameGeral.groupby('payment_type')['payment_value'].mean().reset_index()
correlacao = ticket_medio_por_forma_pagamento.corr()
print(correlacao)


plt.figure(figsize=(10, 5))
plt.bar(ticket_medio_por_forma_pagamento['payment_type'], ticket_medio_por_forma_pagamento['payment_value'])
plt.xlabel('Forma de Pagamento')
plt.ylabel('Ticket Médio')
plt.title('Ticket Médio por Forma de Pagamento')
plt.xticks(rotation=45)
plt.show()

"""6. Crie uma visão para apresentar os produtos mais vendidos no Geral, por Estado e Região"""

dados1 = pd.merge(geolocation,sellers['seller_zip_code_prefix'],on='seller_zip_code_prefix', how='left')

geolocation



produtos_mais_vendidos = frameGeral.groupby('product_id')['order_item_id'].sum().reset_index()
produtos_mais_vendidos = produtos_mais_vendidos.sort_values(by='order_item_id', ascending=False)

produtos_mais_vendidos_por_estado = frameGeral.groupby(['customer_state', 'product_id'])['order_item_id'].sum().reset_index()
produtos_mais_vendidos_por_estado = produtos_mais_vendidos_por_estado.sort_values(by=['customer_state', 'order_item_id'], ascending=[True, False])


frameGeral['regiao'] = frameGeral['customer_state'].map(geolocation)

produtos_mais_vendidos_por_regiao = frameGeral.groupby(['regiao', 'product_id'])['order_item_id'].sum().reset_index()
produtos_mais_vendidos_por_regiao = produtos_mais_vendidos_por_regiao.sort_values(by=['regiao', 'order_item_id'], ascending=[True, False])